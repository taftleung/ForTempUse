// =================================================================================
// 1) REQUEST METADATA GENERATION
// Sets documentTime, businessDate (Hong Kong Time, UTC+08:00) and gatewayRef.
//
// API SPEC REFERENCE:
// - Section 3.3.4.10 documentTime (xs:dateTimeStamp)
// - Section 3.3.4.9 businessDate (xs:date)
// - Section 3.3.4.2 gatewayRef (used as unique request identifier)
// =================================================================================
function computeHongKongNow() {
    const local = new Date();
    const utcMs = local.getTime() + local.getTimezoneOffset() * 60000;
    const hkMs = utcMs + 8 * 60 * 60000;
    return new Date(hkMs);
}
function pad2(n) { return n < 10 ? '0' + n : '' + n; }
function pad3(n) { return n.toString().padStart(3, '0'); }

function setOctopusTimestampsAndGatewayRef() {
    const nowHK = computeHongKongNow();

    const yyyy = nowHK.getFullYear();
    const MM   = pad2(nowHK.getMonth() + 1);
    const dd   = pad2(nowHK.getDate());
    const hh   = pad2(nowHK.getHours());
    const mm   = pad2(nowHK.getMinutes());
    const ss   = pad2(nowHK.getSeconds());
    const SSS  = pad3(nowHK.getMilliseconds());

    // documentTime: YYYY-MM-DDThh:mm:ss.SSS+08:00
    const documentTime = `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}+08:00`;
    // businessDate: YYYY-MM-DD+08:00  (per Octopus spec)
    const businessDate = `${yyyy}-${MM}-${dd}+08:00`;

    pm.collectionVariables.set('document_time', documentTime);
    pm.collectionVariables.set('business_date', businessDate);

    const name = (pm.info && pm.info.requestName || '').toLowerCase();
    const isPaymentRequest      = name.includes('payment request');
    const isPaymentEnquiry      = name.includes('payment enquiry');
    const isPaymentCancellation = name.includes('payment cancellation');

    if (!isPaymentRequest && !isPaymentEnquiry && !isPaymentCancellation) {
        return; // nothing to do
    }

    if (isPaymentRequest) {
        // New gatewayRef each Payment Request: HSBCTEST + YYYYMMDDHHMM
        const ts = `${yyyy}${MM}${dd}${hh}${mm}`;
        const gwRef = `HSBCTEST${ts}`;
        pm.collectionVariables.set('gateway_ref', gwRef);
        pm.collectionVariables.set('last_gateway_ref', gwRef);
    } else {
        // Reuse last gatewayRef for Enquiry/Cancellation
        const last = pm.collectionVariables.get('last_gateway_ref');
        if (last) {
            pm.collectionVariables.set('gateway_ref', last);
        }
    }
}


// =================================================================================
// 2) PMLIB AND FORGE LOADERS
// Utilities to load jsrsasign (pmlib) and forge for standard crypto functions.
// These libraries must be stored in collection variables 'pmlib_code' and 'forge_code'.
// =================================================================================

let _forgeLoaded = false;
function ensureForgeLoaded() {
    if (_forgeLoaded && typeof forge !== 'undefined') return forge;

    const code = pm.collectionVariables.get('forge_code');
    if (!code) throw new Error('forge_code collection variable is empty.');

    // ---- browser-bundle shim: provide a local "window" for forge ----
    if (typeof window === 'undefined') {
        var window = {}; // visible inside eval below
    }

    eval(code); // forge sets itself on global or window.forge

    if (typeof forge === 'undefined' && window && window.forge) {
        forge = window.forge; // grab it from window if needed
    }

    if (typeof forge === 'undefined') {
        throw new Error('forge is still undefined after eval(forge_code).');
    }

    _forgeLoaded = true;
    return forge;
}

let _pmlibCache = null;
function ensurePmlibLoaded() {
    if (_pmlibCache) return _pmlibCache;

    const code = pm.collectionVariables.get('pmlib_code');
    if (!code) throw new Error('pmlib_code collection variable is empty.');

    eval(code); // defines global "pmlib"
    if (typeof pmlib === 'undefined' || !pmlib.rs) {
        throw new Error('pmlib not available after eval(pmlib_code).');
    }

    _pmlibCache = {
        root: pmlib,
        rs: pmlib.rs,
        KEYUTIL: pmlib.rs.KEYUTIL,
        KJUR: pmlib.rs.KJUR
    };
    return _pmlibCache;
}

// =================================================================================
// 3) ENCODING HELPERS
// =================================================================================

function bytesToRawString(bytes) {
    let s = '';
    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
    return s;
}
function rawStringToBytes(str) {
    const out = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) out[i] = str.charCodeAt(i) & 0xff;
    return out;
}
function bytesToB64(bytes) {
    return Buffer.from(bytes).toString('base64');
}
function b64ToBytes(b64) {
    return new Uint8Array(Buffer.from(b64, 'base64'));
}
function bytesToHex(bytes) {
    let out = '';
    for (let i = 0; i < bytes.length; i++) {
        out += bytes[i].toString(16).padStart(2, '0');
    }
    return out;
}

// =================================================================================
// 4) MESSAGE SIGNATURE AND ENCRYPTION (REQUEST)
// Encrypts the plaintext XML body into the final <encryptedContent> document.
// API SPEC REFERENCE: Section 3.2.6 Message Security
// =================================================================================

// ---------------------------------------------------------------------------------
// 4.1 SIGNATURE GENERATION (PG -> OOS)
// Creates the <signedContent> XML by signing the plaintext document.
//
// ALGORITHM: RSASSA-PSS (RSA-PSS) with SHA-256 and MGF1-SHA256
// PARAMETERS: Salt Length = 32 bytes ('psssaltlen: 32')
// SIGNING KEY: PG Private Key (pm.collectionVariables.get('pg_private_key_pem'))
// OUTPUT: <signature signerId="..." keyId="...">
//
// API SPEC REFERENCE: Section 3.2.6.3 Signature
// ---------------------------------------------------------------------------------
function buildSignedContentXml(plaintextXml) {
    const { rs, KEYUTIL, KJUR } = ensurePmlibLoaded();
    const gatewayId = pm.collectionVariables.get('gateway_id');
    if (!gatewayId) {
        throw new Error('gateway_id is not set.');
    }

    const prvPem = pm.collectionVariables.get('pg_private_key_pem');
    if (!prvPem) throw new Error('pg_private_key_pem is not set.');
    const signKeyId = pm.collectionVariables.get('pg_sign_key_id') || '1';

    const prvKeyObj = KEYUTIL.getKey(prvPem);
    // RSASSA-PSS with SHA-256 and MGF1-SHA-256
    const sig = new KJUR.crypto.Signature({
        alg: 'SHA256withRSAandMGF1',
        psssaltlen: 32
    });
    sig.init(prvKeyObj);
    sig.updateString(plaintextXml);
    const sigHex = sig.sign();
    const sigB64 = rs.hextob64(sigHex);

    const contentB64 = Buffer.from(plaintextXml, 'utf8').toString('base64');
    const signedXml =
        '<signedContent xmlns="http://namespace.oos.online.octopus.com.hk/mls/">' +
            `<content>${contentB64}</content>` +
            // Correct format used (signerId for Gateway ID, keyId for Signing Key ID)
            `<signature signerId="${gatewayId}" keyId="${signKeyId}">${sigB64}</signature>` +
        '</signedContent>';
    return signedXml;
}

// ---------------------------------------------------------------------------------
// 4.2 SYMMETRIC ENCRYPTION AND ASYMMETRIC KEY WRAP
// Encrypts the <signedContent> with AES-GCM and then wraps the AES key with RSA-OAEP.
//
// SYMMETRIC ALGORITHM: AES-256-GCM
// PARAMETERS: Key Size = 32 bytes (256-bit), IV Size = 12 bytes (96-bit), Tag Length = 128 bits (16 bytes)
// ASYMMETRIC ALGORITHM: RSAES-OAEP with SHA-256 and MGF1-SHA256 (RSAOAEP256)
// ENCRYPTION KEY: OOS WS Public Key (pm.collectionVariables.get('oos_ws_public_key_pem'))
//
// API SPEC REFERENCE: Section 3.2.6.4 Encryption
// ---------------------------------------------------------------------------------
function encryptSignedContentToEncryptedContentXml(signedContentXml) {
    const forge = ensureForgeLoaded();
    const { rs, KEYUTIL, KJUR } = ensurePmlibLoaded();
    
    // 1) Generate random AES-256 key (32 bytes) and 96-bit IV (12 bytes)
    const keyBytes = rawStringToBytes(forge.random.getBytesSync(32)); 
    const ivBytes  = rawStringToBytes(forge.random.getBytesSync(12)); 

    // 2) AES-GCM encrypt signedContentXml
    const keyStr = bytesToRawString(keyBytes);
    const ivStr  = bytesToRawString(ivBytes);

    const cipher = forge.cipher.createCipher('AES-GCM', keyStr);
    cipher.start({ iv: ivStr, tagLength: 128 });
    cipher.update(forge.util.createBuffer(signedContentXml, 'utf8'));
    const ok = cipher.finish();
    if (!ok) throw new Error('AES-GCM encryption failed.');

    const ciphertextBytes = rawStringToBytes(cipher.output.getBytes());
    const tagBytes        = rawStringToBytes(cipher.mode.tag.getBytes());

    // 3) Encrypt session key with Octopus WS public key (RSAOAEP256)
    const certPem = pm.collectionVariables.get('oos_ws_public_key_pem');
    if (!certPem) throw new Error('oos_ws_public_key_pem is not set.');

    const pubKeyObj = KEYUTIL.getKey(certPem);

    const sessionKeyRaw = bytesToRawString(keyBytes);
    const encKeyHex = KJUR.crypto.Cipher.encrypt(sessionKeyRaw, pubKeyObj, 'RSAOAEP256'); // hex
    const encKeyB64 = rs.hextob64(encKeyHex);

    const keyId = pm.collectionVariables.get('oos_encryption_key_id') || '1';

    const ivB64   = bytesToB64(ivBytes);
    const ciphB64 = bytesToB64(ciphertextBytes);
    const tagB64  = bytesToB64(tagBytes);
    
    // 4) Assemble the final <encryptedContent> XML
    const xml =
        '<encryptedContent xmlns="http://namespace.oos.online.octopus.com.hk/mls/">' +
            `<iv>${ivB64}</iv>` +
            `<ciphertext>${ciphB64}</ciphertext>` +
            `<authenticationTag>${tagB64}</authenticationTag>` +
            `<encryptedKey keyId="${keyId}">${encKeyB64}</encryptedKey>` +
        '</encryptedContent>';

    if (pm.collectionVariables.get('debug_log') === 'true') {
        console.log('[v9 DEBUG] AES keyHex       =', bytesToHex(keyBytes));
        console.log('[v9 DEBUG] AES ivHex        =', bytesToHex(ivBytes));
        console.log('[v9 DEBUG] ciphertextB64    =', ciphB64);
        console.log('[v9 DEBUG] tagB64           =', tagB64);
        console.log('[v9 DEBUG] ciphertextHex    =', bytesToHex(ciphertextBytes));
        console.log('[v9 DEBUG] tagHex           =', bytesToHex(tagBytes));
        console.log('[v9 DEBUG] encKeyHex        =', encKeyHex);
        console.log('[v9 DEBUG] encKeyB64        =', encKeyB64);
    }

    return xml;
}

// =================================================================================
// 5) MAIN PRE-REQUEST ENTRY POINT
// Executes the logic to set metadata, sign, and encrypt the request body.
// =================================================================================

(function mainPreRequest() {
    const name = (pm.info && pm.info.requestName || '').toLowerCase();

    const isPaymentRequest      = name.includes('payment request');
    const isPaymentEnquiry      = name.includes('payment enquiry');
    const isPaymentCancellation = name.includes('payment cancellation');

    if (!isPaymentRequest && !isPaymentEnquiry && !isPaymentCancellation) {
        return; // only wrap the three Octopus payment APIs
    }

    setOctopusTimestampsAndGatewayRef();

    if (!pm.request.body || pm.request.body.mode !== 'raw') {
        throw new Error('Octopus pre-request expects raw XML body.');
    }

    const rawXml   = pm.variables.replaceIn(pm.request.body.raw || '');
    const plainXml = rawXml.trim(); // Ensure no leading/trailing whitespace

    if (!plainXml) {
        throw new Error('Request body is empty â€“ plaintext XML is required.');
    }

    const signedXml    = buildSignedContentXml(plainXml);
    const encryptedXml = encryptSignedContentToEncryptedContentXml(signedXml);

    if (pm.collectionVariables.get('debug_log') === 'true') {
        console.log('--- [v9] Octopus plaintext XML ---\n', plainXml);
        console.log('--- [v9] Octopus signedContent XML ---\n', signedXml);
        console.log('--- [v9] Octopus encryptedContent XML (request body) ---\n', encryptedXml);
    }

    pm.request.body.update(encryptedXml);
})();